{"ast":null,"code":"import { generateUniqueNumber } from 'fast-unique-numbers';\nimport { isCallNotification } from './guards/call-notification';\nimport { isClearResponse } from './guards/clear-response';\nexport const load = url => {\n  // Prefilling the Maps with a function indexed by zero is necessary to be compliant with the specification.\n  const scheduledIntervalFunctions = new Map([[0, () => {}]]); // tslint:disable-line no-empty\n  const scheduledTimeoutFunctions = new Map([[0, () => {}]]); // tslint:disable-line no-empty\n  const unrespondedRequests = new Map();\n  const worker = new Worker(url);\n  worker.addEventListener('message', ({\n    data\n  }) => {\n    if (isCallNotification(data)) {\n      const {\n        params: {\n          timerId,\n          timerType\n        }\n      } = data;\n      if (timerType === 'interval') {\n        const idOrFunc = scheduledIntervalFunctions.get(timerId);\n        if (typeof idOrFunc === 'number') {\n          const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);\n          if (timerIdAndTimerType === undefined || timerIdAndTimerType.timerId !== timerId || timerIdAndTimerType.timerType !== timerType) {\n            throw new Error('The timer is in an undefined state.');\n          }\n        } else if (typeof idOrFunc !== 'undefined') {\n          idOrFunc();\n        } else {\n          throw new Error('The timer is in an undefined state.');\n        }\n      } else if (timerType === 'timeout') {\n        const idOrFunc = scheduledTimeoutFunctions.get(timerId);\n        if (typeof idOrFunc === 'number') {\n          const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);\n          if (timerIdAndTimerType === undefined || timerIdAndTimerType.timerId !== timerId || timerIdAndTimerType.timerType !== timerType) {\n            throw new Error('The timer is in an undefined state.');\n          }\n        } else if (typeof idOrFunc !== 'undefined') {\n          idOrFunc();\n          // A timeout can be savely deleted because it is only called once.\n          scheduledTimeoutFunctions.delete(timerId);\n        } else {\n          throw new Error('The timer is in an undefined state.');\n        }\n      }\n    } else if (isClearResponse(data)) {\n      const {\n        id\n      } = data;\n      const timerIdAndTimerType = unrespondedRequests.get(id);\n      if (timerIdAndTimerType === undefined) {\n        throw new Error('The timer is in an undefined state.');\n      }\n      const {\n        timerId,\n        timerType\n      } = timerIdAndTimerType;\n      unrespondedRequests.delete(id);\n      if (timerType === 'interval') {\n        scheduledIntervalFunctions.delete(timerId);\n      } else {\n        scheduledTimeoutFunctions.delete(timerId);\n      }\n    } else {\n      const {\n        error: {\n          message\n        }\n      } = data;\n      throw new Error(message);\n    }\n  });\n  const clearInterval = timerId => {\n    const id = generateUniqueNumber(unrespondedRequests);\n    unrespondedRequests.set(id, {\n      timerId,\n      timerType: 'interval'\n    });\n    scheduledIntervalFunctions.set(timerId, id);\n    worker.postMessage({\n      id,\n      method: 'clear',\n      params: {\n        timerId,\n        timerType: 'interval'\n      }\n    });\n  };\n  const clearTimeout = timerId => {\n    const id = generateUniqueNumber(unrespondedRequests);\n    unrespondedRequests.set(id, {\n      timerId,\n      timerType: 'timeout'\n    });\n    scheduledTimeoutFunctions.set(timerId, id);\n    worker.postMessage({\n      id,\n      method: 'clear',\n      params: {\n        timerId,\n        timerType: 'timeout'\n      }\n    });\n  };\n  const setInterval = (func, delay = 0) => {\n    const timerId = generateUniqueNumber(scheduledIntervalFunctions);\n    scheduledIntervalFunctions.set(timerId, () => {\n      func();\n      // Doublecheck if the interval should still be rescheduled because it could have been cleared inside of func().\n      if (typeof scheduledIntervalFunctions.get(timerId) === 'function') {\n        worker.postMessage({\n          id: null,\n          method: 'set',\n          params: {\n            delay,\n            now: performance.now(),\n            timerId,\n            timerType: 'interval'\n          }\n        });\n      }\n    });\n    worker.postMessage({\n      id: null,\n      method: 'set',\n      params: {\n        delay,\n        now: performance.now(),\n        timerId,\n        timerType: 'interval'\n      }\n    });\n    return timerId;\n  };\n  const setTimeout = (func, delay = 0) => {\n    const timerId = generateUniqueNumber(scheduledTimeoutFunctions);\n    scheduledTimeoutFunctions.set(timerId, func);\n    worker.postMessage({\n      id: null,\n      method: 'set',\n      params: {\n        delay,\n        now: performance.now(),\n        timerId,\n        timerType: 'timeout'\n      }\n    });\n    return timerId;\n  };\n  return {\n    clearInterval,\n    clearTimeout,\n    setInterval,\n    setTimeout\n  };\n};","map":{"version":3,"names":["generateUniqueNumber","isCallNotification","isClearResponse","load","url","scheduledIntervalFunctions","Map","scheduledTimeoutFunctions","unrespondedRequests","worker","Worker","addEventListener","data","params","timerId","timerType","idOrFunc","get","timerIdAndTimerType","undefined","Error","delete","id","error","message","clearInterval","set","postMessage","method","clearTimeout","setInterval","func","delay","now","performance","setTimeout"],"sources":["C:\\Users\\marce\\node_modules\\worker-timers-broker\\src\\module.ts"],"sourcesContent":["import { generateUniqueNumber } from 'fast-unique-numbers';\nimport { IClearRequest, ISetNotification, IWorkerEvent, TTimerType } from 'worker-timers-worker';\nimport { isCallNotification } from './guards/call-notification';\nimport { isClearResponse } from './guards/clear-response';\n\nexport const load = (url: string) => {\n    // Prefilling the Maps with a function indexed by zero is necessary to be compliant with the specification.\n    const scheduledIntervalFunctions: Map<number, number | Function> = new Map([[0, () => {}]]); // tslint:disable-line no-empty\n    const scheduledTimeoutFunctions: Map<number, number | Function> = new Map([[0, () => {}]]); // tslint:disable-line no-empty\n    const unrespondedRequests: Map<number, { timerId: number; timerType: TTimerType }> = new Map();\n\n    const worker = new Worker(url);\n\n    worker.addEventListener('message', ({ data }: IWorkerEvent) => {\n        if (isCallNotification(data)) {\n            const {\n                params: { timerId, timerType }\n            } = data;\n\n            if (timerType === 'interval') {\n                const idOrFunc = scheduledIntervalFunctions.get(timerId);\n\n                if (typeof idOrFunc === 'number') {\n                    const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);\n\n                    if (\n                        timerIdAndTimerType === undefined ||\n                        timerIdAndTimerType.timerId !== timerId ||\n                        timerIdAndTimerType.timerType !== timerType\n                    ) {\n                        throw new Error('The timer is in an undefined state.');\n                    }\n                } else if (typeof idOrFunc !== 'undefined') {\n                    idOrFunc();\n                } else {\n                    throw new Error('The timer is in an undefined state.');\n                }\n            } else if (timerType === 'timeout') {\n                const idOrFunc = scheduledTimeoutFunctions.get(timerId);\n\n                if (typeof idOrFunc === 'number') {\n                    const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);\n\n                    if (\n                        timerIdAndTimerType === undefined ||\n                        timerIdAndTimerType.timerId !== timerId ||\n                        timerIdAndTimerType.timerType !== timerType\n                    ) {\n                        throw new Error('The timer is in an undefined state.');\n                    }\n                } else if (typeof idOrFunc !== 'undefined') {\n                    idOrFunc();\n\n                    // A timeout can be savely deleted because it is only called once.\n                    scheduledTimeoutFunctions.delete(timerId);\n                } else {\n                    throw new Error('The timer is in an undefined state.');\n                }\n            }\n        } else if (isClearResponse(data)) {\n            const { id } = data;\n\n            const timerIdAndTimerType = unrespondedRequests.get(id);\n\n            if (timerIdAndTimerType === undefined) {\n                throw new Error('The timer is in an undefined state.');\n            }\n\n            const { timerId, timerType } = timerIdAndTimerType;\n\n            unrespondedRequests.delete(id);\n\n            if (timerType === 'interval') {\n                scheduledIntervalFunctions.delete(timerId);\n            } else {\n                scheduledTimeoutFunctions.delete(timerId);\n            }\n        } else {\n            const {\n                error: { message }\n            } = data;\n\n            throw new Error(message);\n        }\n    });\n\n    const clearInterval = (timerId: number) => {\n        const id = generateUniqueNumber(unrespondedRequests);\n\n        unrespondedRequests.set(id, { timerId, timerType: 'interval' });\n        scheduledIntervalFunctions.set(timerId, id);\n\n        worker.postMessage(<IClearRequest>{\n            id,\n            method: 'clear',\n            params: { timerId, timerType: 'interval' }\n        });\n    };\n\n    const clearTimeout = (timerId: number) => {\n        const id = generateUniqueNumber(unrespondedRequests);\n\n        unrespondedRequests.set(id, { timerId, timerType: 'timeout' });\n        scheduledTimeoutFunctions.set(timerId, id);\n\n        worker.postMessage(<IClearRequest>{\n            id,\n            method: 'clear',\n            params: { timerId, timerType: 'timeout' }\n        });\n    };\n\n    const setInterval = (func: Function, delay = 0) => {\n        const timerId = generateUniqueNumber(scheduledIntervalFunctions);\n\n        scheduledIntervalFunctions.set(timerId, () => {\n            func();\n\n            // Doublecheck if the interval should still be rescheduled because it could have been cleared inside of func().\n            if (typeof scheduledIntervalFunctions.get(timerId) === 'function') {\n                worker.postMessage(<ISetNotification>{\n                    id: null,\n                    method: 'set',\n                    params: {\n                        delay,\n                        now: performance.now(),\n                        timerId,\n                        timerType: 'interval'\n                    }\n                });\n            }\n        });\n\n        worker.postMessage(<ISetNotification>{\n            id: null,\n            method: 'set',\n            params: {\n                delay,\n                now: performance.now(),\n                timerId,\n                timerType: 'interval'\n            }\n        });\n\n        return timerId;\n    };\n\n    const setTimeout = (func: Function, delay = 0) => {\n        const timerId = generateUniqueNumber(scheduledTimeoutFunctions);\n\n        scheduledTimeoutFunctions.set(timerId, func);\n\n        worker.postMessage(<ISetNotification>{\n            id: null,\n            method: 'set',\n            params: {\n                delay,\n                now: performance.now(),\n                timerId,\n                timerType: 'timeout'\n            }\n        });\n\n        return timerId;\n    };\n\n    return {\n        clearInterval,\n        clearTimeout,\n        setInterval,\n        setTimeout\n    };\n};\n"],"mappings":"AAAA,SAASA,oBAAoB,QAAQ,qBAAqB;AAE1D,SAASC,kBAAkB,QAAQ,4BAA4B;AAC/D,SAASC,eAAe,QAAQ,yBAAyB;AAEzD,OAAO,MAAMC,IAAI,GAAIC,GAAW,IAAI;EAChC;EACA,MAAMC,0BAA0B,GAAmC,IAAIC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,MAAK,CAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAC7F,MAAMC,yBAAyB,GAAmC,IAAID,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,MAAK,CAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAC5F,MAAME,mBAAmB,GAA4D,IAAIF,GAAG,EAAE;EAE9F,MAAMG,MAAM,GAAG,IAAIC,MAAM,CAACN,GAAG,CAAC;EAE9BK,MAAM,CAACE,gBAAgB,CAAC,SAAS,EAAE,CAAC;IAAEC;EAAI,CAAgB,KAAI;IAC1D,IAAIX,kBAAkB,CAACW,IAAI,CAAC,EAAE;MAC1B,MAAM;QACFC,MAAM,EAAE;UAAEC,OAAO;UAAEC;QAAS;MAAE,CACjC,GAAGH,IAAI;MAER,IAAIG,SAAS,KAAK,UAAU,EAAE;QAC1B,MAAMC,QAAQ,GAAGX,0BAA0B,CAACY,GAAG,CAACH,OAAO,CAAC;QAExD,IAAI,OAAOE,QAAQ,KAAK,QAAQ,EAAE;UAC9B,MAAME,mBAAmB,GAAGV,mBAAmB,CAACS,GAAG,CAACD,QAAQ,CAAC;UAE7D,IACIE,mBAAmB,KAAKC,SAAS,IACjCD,mBAAmB,CAACJ,OAAO,KAAKA,OAAO,IACvCI,mBAAmB,CAACH,SAAS,KAAKA,SAAS,EAC7C;YACE,MAAM,IAAIK,KAAK,CAAC,qCAAqC,CAAC;UAC1D;QACJ,CAAC,MAAM,IAAI,OAAOJ,QAAQ,KAAK,WAAW,EAAE;UACxCA,QAAQ,EAAE;QACd,CAAC,MAAM;UACH,MAAM,IAAII,KAAK,CAAC,qCAAqC,CAAC;QAC1D;MACJ,CAAC,MAAM,IAAIL,SAAS,KAAK,SAAS,EAAE;QAChC,MAAMC,QAAQ,GAAGT,yBAAyB,CAACU,GAAG,CAACH,OAAO,CAAC;QAEvD,IAAI,OAAOE,QAAQ,KAAK,QAAQ,EAAE;UAC9B,MAAME,mBAAmB,GAAGV,mBAAmB,CAACS,GAAG,CAACD,QAAQ,CAAC;UAE7D,IACIE,mBAAmB,KAAKC,SAAS,IACjCD,mBAAmB,CAACJ,OAAO,KAAKA,OAAO,IACvCI,mBAAmB,CAACH,SAAS,KAAKA,SAAS,EAC7C;YACE,MAAM,IAAIK,KAAK,CAAC,qCAAqC,CAAC;UAC1D;QACJ,CAAC,MAAM,IAAI,OAAOJ,QAAQ,KAAK,WAAW,EAAE;UACxCA,QAAQ,EAAE;UAEV;UACAT,yBAAyB,CAACc,MAAM,CAACP,OAAO,CAAC;QAC7C,CAAC,MAAM;UACH,MAAM,IAAIM,KAAK,CAAC,qCAAqC,CAAC;QAC1D;MACJ;IACJ,CAAC,MAAM,IAAIlB,eAAe,CAACU,IAAI,CAAC,EAAE;MAC9B,MAAM;QAAEU;MAAE,CAAE,GAAGV,IAAI;MAEnB,MAAMM,mBAAmB,GAAGV,mBAAmB,CAACS,GAAG,CAACK,EAAE,CAAC;MAEvD,IAAIJ,mBAAmB,KAAKC,SAAS,EAAE;QACnC,MAAM,IAAIC,KAAK,CAAC,qCAAqC,CAAC;MAC1D;MAEA,MAAM;QAAEN,OAAO;QAAEC;MAAS,CAAE,GAAGG,mBAAmB;MAElDV,mBAAmB,CAACa,MAAM,CAACC,EAAE,CAAC;MAE9B,IAAIP,SAAS,KAAK,UAAU,EAAE;QAC1BV,0BAA0B,CAACgB,MAAM,CAACP,OAAO,CAAC;MAC9C,CAAC,MAAM;QACHP,yBAAyB,CAACc,MAAM,CAACP,OAAO,CAAC;MAC7C;IACJ,CAAC,MAAM;MACH,MAAM;QACFS,KAAK,EAAE;UAAEC;QAAO;MAAE,CACrB,GAAGZ,IAAI;MAER,MAAM,IAAIQ,KAAK,CAACI,OAAO,CAAC;IAC5B;EACJ,CAAC,CAAC;EAEF,MAAMC,aAAa,GAAIX,OAAe,IAAI;IACtC,MAAMQ,EAAE,GAAGtB,oBAAoB,CAACQ,mBAAmB,CAAC;IAEpDA,mBAAmB,CAACkB,GAAG,CAACJ,EAAE,EAAE;MAAER,OAAO;MAAEC,SAAS,EAAE;IAAU,CAAE,CAAC;IAC/DV,0BAA0B,CAACqB,GAAG,CAACZ,OAAO,EAAEQ,EAAE,CAAC;IAE3Cb,MAAM,CAACkB,WAAW,CAAgB;MAC9BL,EAAE;MACFM,MAAM,EAAE,OAAO;MACff,MAAM,EAAE;QAAEC,OAAO;QAAEC,SAAS,EAAE;MAAU;KAC3C,CAAC;EACN,CAAC;EAED,MAAMc,YAAY,GAAIf,OAAe,IAAI;IACrC,MAAMQ,EAAE,GAAGtB,oBAAoB,CAACQ,mBAAmB,CAAC;IAEpDA,mBAAmB,CAACkB,GAAG,CAACJ,EAAE,EAAE;MAAER,OAAO;MAAEC,SAAS,EAAE;IAAS,CAAE,CAAC;IAC9DR,yBAAyB,CAACmB,GAAG,CAACZ,OAAO,EAAEQ,EAAE,CAAC;IAE1Cb,MAAM,CAACkB,WAAW,CAAgB;MAC9BL,EAAE;MACFM,MAAM,EAAE,OAAO;MACff,MAAM,EAAE;QAAEC,OAAO;QAAEC,SAAS,EAAE;MAAS;KAC1C,CAAC;EACN,CAAC;EAED,MAAMe,WAAW,GAAGA,CAACC,IAAc,EAAEC,KAAK,GAAG,CAAC,KAAI;IAC9C,MAAMlB,OAAO,GAAGd,oBAAoB,CAACK,0BAA0B,CAAC;IAEhEA,0BAA0B,CAACqB,GAAG,CAACZ,OAAO,EAAE,MAAK;MACzCiB,IAAI,EAAE;MAEN;MACA,IAAI,OAAO1B,0BAA0B,CAACY,GAAG,CAACH,OAAO,CAAC,KAAK,UAAU,EAAE;QAC/DL,MAAM,CAACkB,WAAW,CAAmB;UACjCL,EAAE,EAAE,IAAI;UACRM,MAAM,EAAE,KAAK;UACbf,MAAM,EAAE;YACJmB,KAAK;YACLC,GAAG,EAAEC,WAAW,CAACD,GAAG,EAAE;YACtBnB,OAAO;YACPC,SAAS,EAAE;;SAElB,CAAC;MACN;IACJ,CAAC,CAAC;IAEFN,MAAM,CAACkB,WAAW,CAAmB;MACjCL,EAAE,EAAE,IAAI;MACRM,MAAM,EAAE,KAAK;MACbf,MAAM,EAAE;QACJmB,KAAK;QACLC,GAAG,EAAEC,WAAW,CAACD,GAAG,EAAE;QACtBnB,OAAO;QACPC,SAAS,EAAE;;KAElB,CAAC;IAEF,OAAOD,OAAO;EAClB,CAAC;EAED,MAAMqB,UAAU,GAAGA,CAACJ,IAAc,EAAEC,KAAK,GAAG,CAAC,KAAI;IAC7C,MAAMlB,OAAO,GAAGd,oBAAoB,CAACO,yBAAyB,CAAC;IAE/DA,yBAAyB,CAACmB,GAAG,CAACZ,OAAO,EAAEiB,IAAI,CAAC;IAE5CtB,MAAM,CAACkB,WAAW,CAAmB;MACjCL,EAAE,EAAE,IAAI;MACRM,MAAM,EAAE,KAAK;MACbf,MAAM,EAAE;QACJmB,KAAK;QACLC,GAAG,EAAEC,WAAW,CAACD,GAAG,EAAE;QACtBnB,OAAO;QACPC,SAAS,EAAE;;KAElB,CAAC;IAEF,OAAOD,OAAO;EAClB,CAAC;EAED,OAAO;IACHW,aAAa;IACbI,YAAY;IACZC,WAAW;IACXK;GACH;AACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}